<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">

<title>A Castle in the Cloud</title>

<script type="text/javascript">
// Frame buster
if(top !== self) {
  top.location.replace(self.location.href);
}
</script>

<link rel="stylesheet" href="font-awesome/css/font-awesome.min.css">

<script type="text/javascript" src="three.min.js"></script>
<script type="text/javascript" src="three.Densaugeo.js"></script>

<style type="text/css">
canvas {
  position: absolute;
  top:      0;
  bottom:   0;
  left:     48px;
  right:    0;
  z-index:  0;
  padding:  0;
  border:   none;
  margin:   0;
}
#sidebar {
  position: fixed;
  top: 0;
  bottom: 0;
  left: 0;
  width: 48px;
  z-index: 1;
}
#sidebar > i {
  font-size: 24px;
  width: 24px;
  text-align: center;
  margin: 12px;
}

#help {
  position: absolute;
  top:      10px;
  left:     58px;
  z-index:  1;
  visibility: hidden;
  color:    #FFF;
  background-color: #000;
}
</style>
</head>

<body id="body">

<div id='sidebar'>
<i id="help_button" class="fa fa-question button" title="F1 - Help"></i>
<i id="shader_button" class="fa fa-eye button" title="F2 - Trippy shader"></i>
<i id="fullscreen_button" class="fa fa-arrows-alt button" title="F3 - Fullscreen"></i>
</div>

<text id='help'>
Touchscreen:
<br />
First finger drag - Pan
<br />
Second finger drag - Rotate
<br />
Tilt while touching screen - Rotate
<br />
Slide along right edge - Throttle
<br />
<br />
Mouse:
<br />
Left click and drag - Pan
<br />
Right click and drag - Rotate
<br />
Scroll wheel - Dolly
<br />
Shift click - Activate mouse look
<br />
Esc - Exit mouse look
<br />
<br />
Keyboard:
<br />
W/S - Fly forward/backward
<br />
A/D - Strafe left/right
<br />
E/C - Ascend/Descend
<br />
Arrows - Turn
<br />
<br />
Gamepad (press any face button to activate):
<br />
Left stick - Pan
<br />
Right stick - Turn
<br />
Left/right trigger - Throttle back/forward
</text>

<a title="Real Time Web Analytics" style="visibility:hidden" href="http://clicky.com/100755588"><img alt="Real Time Web Analytics" src="//static.getclicky.com/media/links/badge.gif" border="0" /></a>
<script type="text/javascript">
var clicky_site_ids = clicky_site_ids || [];
clicky_site_ids.push(100755588);
(function() {
  var s = document.createElement('script');
  s.type = 'text/javascript';
  s.async = true;
  s.src = '//static.getclicky.com/js';
  ( document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0] ).appendChild( s );
})();
</script>
<noscript><p><img alt="Clicky" width="1" height="1" src="//in.getclicky.com/100755588ns.gif" /></p></noscript>

</body>

<script type="text/javascript">

////////
// UI //
////////

var grids = new THREE.Densaugeo.CoordinateMaterial();
var trippyGridShader = new THREE.Densaugeo.CoordinateMaterial({side: THREE.DoubleSide, local: true, showAxes: new THREE.Vector3(0, 0, 0)});
var ghosty = new THREE.Densaugeo.PositionMaterial({transparent: true, alpha: 0.8});
var normalses = new THREE.Densaugeo.NormalMaterial();
var weedShader = new THREE.Densaugeo.PsychMaterial();

var specialShaders = [grids, trippyGridShader, ghosty, normalses, weedShader];

var changeMaterials = function(object) {
  if(object instanceof THREE.Mesh) {
    switch(specialShaders.indexOf(object.material)) {
      case -1:
        object.originalMaterial = object.material;
        object.material = specialShaders[0];
        break;
      case specialShaders.length - 1:
        object.material = object.originalMaterial;
        break;
      default:
        object.material = specialShaders[specialShaders.indexOf(object.material) + 1];
    }
  }
  
  if(object instanceof THREE.Object3D) {
    for(var i = 0, endi = object.children.length; i < endi; ++i) {
      changeMaterials(object.children[i]);
    }
  }
}

if(HTMLElement.prototype.requestFullscreen == null) {
  HTMLElement.prototype.requestFullscreen = HTMLElement.prototype.msRequestFullscreen || HTMLElement.prototype.mozRequestFullScreen || HTMLElement.prototype.webkitRequestFullscreen;
}
if(document.exitFullscreen == null) {
  document.exitFullscreen = document.msExitFullscreen || document.mozCancelFullScreen || document.webkitExitFullscreen;
}
var getFullscreenElement = function() {
  return document.fullscreenElement || document.msFullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;
}

document.addEventListener('keydown', function(e) {
  switch(e.keyCode) {
    case 112: // F1 - Toggle help
      var style = document.getElementById('help').style;
      style.visibility = style.visibility === 'hidden' ? 'visible' : 'hidden';
      break;
    case 113: // F2 - Toggle shader
      changeMaterials(scene);
      break;
    case 114: // F3 - Fullscreen
      e.preventDefault();
      
      if(getFullscreenElement() == null) {
        document.body.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
      break;
  }
});

document.getElementById('help_button').addEventListener('click', function(e) {
  var style = document.getElementById('help').style;
  style.visibility = style.visibility === 'visible' ? 'hidden' : 'visible';
});

document.getElementById('shader_button').addEventListener('click', function(e) {
  changeMaterials(scene);
});

document.getElementById('fullscreen_button').addEventListener('click', function(e) {
  e.preventDefault();
  
  if(getFullscreenElement() == null) {
    document.body.requestFullscreen();
  } else {
    document.exitFullscreen();
  }
});

/////////////////
// THREE setup //
/////////////////

var scene = new THREE.Scene();

var camera = new THREE.PerspectiveCamera(45, (window.innerWidth - 48)/window.innerHeight, 1, 1000);
camera.matrix.set(
  0.8583453893661499, -0.2562495470046997, 0.4444985091686249, 28.422760009765625,
  0.5130719542503357, 0.4286935329437256, -0.7436251044273376, -49.2386474609375,
  0, 0.8663473129272461, 0.49944186210632324, 27.35080909729004,
  0, 0, 0, 1
);

scene.add(camera);

var ambientLight = new THREE.AmbientLight(0x7F7F7F);
scene.add(ambientLight);

var directionalLight = new THREE.DirectionalLight(0x808080);
directionalLight.position.set(-7.1, 2.75, 10);
scene.add(directionalLight);

var loader = new THREE.Densaugeo.JSONMultiLoader();

var renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth - 48, window.innerHeight);
renderer.setClearColor(0xC0C0C0, 1);

document.body.appendChild(renderer.domElement);

var controls = new THREE.Densaugeo.FreeControls(camera, renderer.domElement, {panMouseSpeed: 0.05, dollySpeed: 5});

// WebGL occupies entire browser window
window.addEventListener("resize", function() {
  camera.aspect = (window.innerWidth - 48)/window.innerHeight;
  camera.updateProjectionMatrix();
  
  renderer.setSize(window.innerWidth - 48, window.innerHeight);
});

////////////////////
// Graphical data //
////////////////////

var models = [
  "models/Annex_Door.json",
  "models/Annex_Gate.json",
  "models/Annex_Wall_1.json",
  "models/Annex_Wall_2.json",
  "models/Annex_Wall_S_End.json",
  "models/Annex_Wall_Stretched.json",
  "models/Citadel_Door.json",
  "models/Citadel_Door_Side.json",
  "models/Citadel_Mezzanine.json",
  "models/Citadel_Side.json",
  "models/Fortress_Bridge_Extension.json",
  "models/Fortress_Bridge.json",
  "models/Fortress_Bridge_Wall_1_Extension.json",
  "models/Fortress_Bridge_Wall_1.json",
  "models/Fortress_Bridge_Wall_2.json",
  "models/Fortress_Bridge_Wall_Mirrored_2.json",
  "models/Fortress_Causeway_Drawbridge.json",
  "models/Fortress_Causeway_Drop.json",
  "models/Fortress_Causeway.json",
  "models/Fortress_Corner.json",
  "models/Fortress_Dock.json",
  "models/Fortress_Gate_1_Banner.json",
  "models/Fortress_Gate_1.json",
  "models/Fortress_Gate_1_L_Door.json",
  "models/Fortress_Gate_1_R_Door.json",
  "models/Fortress_Gate_1_Spiral.json",
  "models/Fortress_Gate_2_Drawbridge.json",
  "models/Fortress_Gate_2.json",
  "models/Fortress_Gate_3_Drawbridge.json",
  "models/Fortress_Gate_3_Wall.json",
  "models/Fortress_Gate_3.json",
  "models/Fortress_Inner_Corner.json",
  "models/Fortress_Ramp.json",
  "models/Fortress_Tower_Base_1.json",
  "models/Fortress_Tower_Base_2.json",
  "models/Fortress_Tower_E.json",
  "models/Fortress_Tower_Lower_Drawbridge.json",
  "models/Fortress_Tower_Upper_Drawbridge.json",
  "models/Fortress_Tower_W.json",
  "models/Fortress_Wall_Battlement.json",
  "models/Fortress_Wall.json",
  "models/Gilded_Bridge_Wall.json",
  "models/Gilded_Fortress_Bridge.json",
  "models/Gilded_Keep_Battlement.json",
  "models/Gilded_Keep_Corner.json",
  "models/Gilded_Keep_Wall.json",
  "models/Ground.json",
  "models/Harbor_Bridge.json",
  "models/Harbor_Gate.json",
  "models/Harbor_Gate_Mirrored.json",
  "models/Harbor_Island_Door.json",
  "models/Harbor_Island.json",
  "models/Harbor_Tower_N.json",
  "models/Harbor_Tower_S.json",
  "models/Keep_Corner.json",
  "models/Keep_Dock_Bridge.json",
  "models/Keep_Dock.json",
  "models/Keep_Tower.json",
  "models/Keep_Tower_Supports_3S.json",
  "models/Keep_Tower_Supports.json",
  "models/Keep_Wall_Battlement.json",
  "models/Keep_Wall.json",
]

var f3D = THREE.Densaugeo.forgeObject3D;
var fM  = THREE.Densaugeo.forgeMesh;

//scene.add(f3D(THREE.Mesh, {geometry: new THREE.PlaneGeometry(128, 128, 1, 1), material: waterShader, position: [0, 0, -0.5]}));
scene.add(water = f3D(THREE.Mesh, {geometry: new THREE.PlaneGeometry(128, 128, 1, 1), material: new THREE.Densaugeo.WaterMaterial({side: THREE.DoubleSide}), position: [0, 0, -0.5]}));

loader.loadAll(models, function(geometries, materialses) {
  var geometry, material;
  
  // Stock the O3D/Mesh forge. Strip paths and file extensions from model names
  for(var i in geometries) {
    fM.geometries[i.split('/').pop().split('.').shift()] = geometries[i];
  }
  for(var i in materialses) {
    fM.materials[i.split('/').pop().split('.').shift()] = new THREE.MeshFaceMaterial(materialses[i]).makeFlat();
  }
  
  keep = f3D(THREE.Object3D, {}, [
    fM('Keep_Tower'          , {}),
    fM('Keep_Tower_Supports' , {}),
    fM('Keep_Wall'           , {position: [ 0, -3, 0]}),
    fM('Keep_Wall'           , {position: [ 3,  0, 0], euler: [0, 0, 0.5*Math.PI]}),
    fM('Keep_Wall'           , {position: [ 0,  3, 0], euler: [0, 0,     Math.PI]}),
    fM('Keep_Wall'           , {position: [-3,  0, 0], euler: [0, 0, 1.5*Math.PI]}),
    fM('Keep_Corner'         , {position: [-3, -3, 0]}),
    fM('Keep_Corner'         , {position: [ 3, -3, 0], euler: [0, 0, 0.5*Math.PI]}),
    fM('Keep_Corner'         , {position: [ 3,  3, 0], euler: [0, 0,     Math.PI]}),
    fM('Keep_Corner'         , {position: [-3,  3, 0], euler: [0, 0, 1.5*Math.PI]}),
    fM('Keep_Wall_Battlement', {position: [ 2, -3, 0]}),
    fM('Keep_Wall_Battlement', {position: [ 2,  3, 0], euler: [0, 0,     Math.PI]}),
    fM('Keep_Wall_Battlement', {position: [-3,  2, 0], euler: [0, 0, 1.5*Math.PI]}),
    fM('Keep_Wall_Battlement', {position: [-3, -2, 0], euler: [0, 0, 1.5*Math.PI]}),
  ]);
  
  harborKeep = f3D(THREE.Object3D, {}, [
    fM('Keep_Tower'            , {position: [-8, 0, 0]}),
    fM('Keep_Tower_Supports_3S', {position: [-8, 0, 0]}),
    fM('Keep_Tower'            , {}),
    fM('Keep_Tower_Supports_3S', {euler: [0, 0, Math.PI]}),
    
    fM('Keep_Corner'         , {position: [-11, -3, 0]}),
    fM('Keep_Wall_Battlement', {position: [-10, -3, 0]}),
    fM('Keep_Wall'           , {position: [- 8, -3, 0]}),
    fM('Keep_Wall_Battlement', {position: [- 6, -3, 0]}),
    fM('Keep_Wall'           , {position: [- 4, -3, 0]}),
    fM('Keep_Wall'           , {position: [  0, -3, 0]}),
    fM('Keep_Wall_Battlement', {position: [  2, -3, 0]}),
    fM('Keep_Corner'         , {position: [  3, -3, 0], euler: [0, 0, 0.5*Math.PI]}),
    fM('Keep_Wall_Battlement', {position: [  3, -2, 0], euler: [0, 0, 0.5*Math.PI]}),
    fM('Keep_Wall'           , {position: [  3,  0, 0], euler: [0, 0, 0.5*Math.PI]}),
    fM('Keep_Wall_Battlement', {position: [  3,  2, 0], euler: [0, 0, 0.5*Math.PI]}),
    fM('Keep_Corner'         , {position: [  3,  3, 0], euler: [0, 0,     Math.PI]}),
    fM('Keep_Wall_Battlement', {position: [  2,  3, 0], euler: [0, 0,     Math.PI]}),
    fM('Keep_Wall'           , {position: [  0,  3, 0], euler: [0, 0,     Math.PI]}),
    fM('Keep_Wall_Battlement', {position: [- 2,  3, 0], euler: [0, 0,     Math.PI]}),
    fM('Keep_Wall'           , {position: [- 4,  3, 0], euler: [0, 0,     Math.PI]}),
    fM('Keep_Wall_Battlement', {position: [- 6,  3, 0], euler: [0, 0,     Math.PI]}),
    fM('Keep_Wall'           , {position: [- 8,  3, 0], euler: [0, 0,     Math.PI]}),
    fM('Keep_Wall_Battlement', {position: [-10,  3, 0], euler: [0, 0,     Math.PI]}),
    fM('Keep_Corner'         , {position: [-11,  3, 0], euler: [0, 0, 1.5*Math.PI]}),
    fM('Keep_Wall_Battlement', {position: [-11,  2, 0], euler: [0, 0, 1.5*Math.PI]}),
    fM('Keep_Wall'           , {position: [-11,  0, 0], euler: [0, 0, 1.5*Math.PI]}),
  ]);
  
  gildedKeep = f3D(THREE.Object3D, {}, [
    fM('Keep_Tower'            , {}),
    fM('Keep_Tower_Supports'   , {}),
    fM('Gilded_Keep_Wall'      , {position: [ 0, -3, 0]}),
    fM('Gilded_Keep_Wall'      , {position: [ 3,  0, 0], euler: [0, 0, 0.5*Math.PI]}),
    fM('Gilded_Keep_Wall'      , {position: [ 0,  3, 0], euler: [0, 0,     Math.PI]}),
    fM('Gilded_Keep_Wall'      , {position: [-3,  0, 0], euler: [0, 0, 1.5*Math.PI]}),
    fM('Gilded_Keep_Corner'    , {position: [-3, -3, 0]}),
    fM('Gilded_Keep_Corner'    , {position: [ 3, -3, 0], euler: [0, 0, 0.5*Math.PI]}),
    fM('Gilded_Keep_Corner'    , {position: [ 3,  3, 0], euler: [0, 0,     Math.PI]}),
    fM('Gilded_Keep_Corner'    , {position: [-3,  3, 0], euler: [0, 0, 1.5*Math.PI]}),
    fM('Gilded_Keep_Battlement', {position: [-2, -3, 0]}),
    fM('Gilded_Keep_Battlement', {position: [ 2, -3, 0]}),
    fM('Gilded_Keep_Battlement', {position: [ 3, -2, 0], euler: [0, 0, 0.5*Math.PI]}),
    fM('Gilded_Keep_Battlement', {position: [ 3,  2, 0], euler: [0, 0, 0.5*Math.PI]}),
    fM('Gilded_Keep_Battlement', {position: [-2,  3, 0], euler: [0, 0,     Math.PI]}),
    fM('Gilded_Keep_Battlement', {position: [-3, -2, 0], euler: [0, 0, 1.5*Math.PI]}),
  ]);
  
  fortressTower1 = f3D(THREE.Object3D, {}, [
    fM('Fortress_Tower_Base_1'          , {position: [0  ,  0  , 0  ]}),
    fM('Fortress_Tower_E'               , {position: [0  ,  0  , 4.2]}),
    fM('Fortress_Tower_Lower_Drawbridge', {position: [0.5, -1.5, 4.4]}),
    fM('Fortress_Tower_Upper_Drawbridge', {position: [0.5, -1.5, 7.6]}),
  ]);
  
  fortressTower2 = f3D(THREE.Object3D, {}, [
    fM('Fortress_Tower_Base_2'          , {position: [ 0  ,  0  , 0  ]}),
    fM('Fortress_Tower_W'               , {position: [ 0  ,  0  , 4.2]}),
    fM('Fortress_Tower_Lower_Drawbridge', {position: [-0.5, -1.5, 4.4]}),
    fM('Fortress_Tower_Upper_Drawbridge', {position: [-0.5, -1.5, 7.6]}),
  ]);
  
  fortressGate2 = f3D(THREE.Object3D, {}, [
    fM('Fortress_Gate_2'           , {position: [0,  0  , 0  ]}),
    fM('Fortress_Gate_2_Drawbridge', {position: [0, -2  , 3.8]}),
    fM('Fortress_Ramp'             , {position: [0, -4.5, 0  ], euler: [0, 0, Math.PI]}),
    fM('Fortress_Ramp'             , {position: [0, -4.5, 0  ]}),
  ]);
  
  annexGate = f3D(THREE.Object3D, {}, [
    fM('Annex_Gate', {position: [ 0  ,  0  , 0]}),
    fM('Annex_Door', {position: [-0.6,  1.2, 0]}),
    fM('Annex_Door', {position: [-0.6, -1.2, 0], euler: [0, 0, Math.PI]}),
  ]);
  
  scene.add(
    ground = fM('Ground', {}),
    fortress = f3D(THREE.Object3D, {position: [0, 0, 0]}, [
      fM('Fortress_Gate_1'       , {position: [ 0  , -21   , 0  ]}),
      fM('Fortress_Gate_1_R_Door', {position: [-1.5, -25   , 4  ]}),
      fM('Fortress_Gate_1_R_Door', {position: [ 1.5, -25   , 4  ]}),
      fM('Fortress_Gate_1_Banner', {position: [-2.5, -28.25, 7.8]}),
      fM('Fortress_Gate_1_Banner', {position: [ 2.5, -28.25, 7.8]}),
      fM('Fortress_Gate_1_Spiral', {position: [-2.5, -27.5 , 0.2], euler: [0, 0, 7.5/180*Math.PI]}),
      fM('Fortress_Gate_1_Spiral', {position: [-2.5, -27.5 , 0.6], euler: [0, 0, 7.5/180*Math.PI]}),
      fM('Fortress_Gate_1_Spiral', {position: [-2.5, -27.5 , 1.0], euler: [0, 0, 7.5/180*Math.PI]}),
      fM('Fortress_Gate_1_Spiral', {position: [-2.5, -27.5 , 1.4], euler: [0, 0, 7.5/180*Math.PI]}),
      fM('Fortress_Gate_1_Spiral', {position: [-2.5, -27.5 , 1.8], euler: [0, 0, 7.5/180*Math.PI]}),
      fM('Fortress_Gate_1_Spiral', {position: [-2.5, -27.5 , 2.2], euler: [0, 0, 7.5/180*Math.PI]}),
      fM('Fortress_Gate_1_Spiral', {position: [-2.5, -27.5 , 2.6], euler: [0, 0, 7.5/180*Math.PI]}),
      fM('Fortress_Gate_1_Spiral', {position: [-2.5, -27.5 , 3.0], euler: [0, 0, 7.5/180*Math.PI]}),
      fM('Fortress_Gate_1_Spiral', {position: [ 2.5, -27.5 , 0.2], euler: [0, 0, 172.5/180*Math.PI]}),
      fM('Fortress_Gate_1_Spiral', {position: [ 2.5, -27.5 , 0.6], euler: [0, 0, 172.5/180*Math.PI]}),
      fM('Fortress_Gate_1_Spiral', {position: [ 2.5, -27.5 , 1.0], euler: [0, 0, 172.5/180*Math.PI]}),
      fM('Fortress_Gate_1_Spiral', {position: [ 2.5, -27.5 , 1.4], euler: [0, 0, 172.5/180*Math.PI]}),
      fM('Fortress_Gate_1_Spiral', {position: [ 2.5, -27.5 , 1.8], euler: [0, 0, 172.5/180*Math.PI]}),
      fM('Fortress_Gate_1_Spiral', {position: [ 2.5, -27.5 , 2.2], euler: [0, 0, 172.5/180*Math.PI]}),
      fM('Fortress_Gate_1_Spiral', {position: [ 2.5, -27.5 , 2.6], euler: [0, 0, 172.5/180*Math.PI]}),
      fM('Fortress_Gate_1_Spiral', {position: [ 2.5, -27.5 , 3.0], euler: [0, 0, 172.5/180*Math.PI]}),
      fM('Fortress_Ramp'         , {position: [ 0  , -23   , 0  ], euler: [0, 0, 1.5*Math.PI]}),
      
      fM('Fortress_Wall_Battlement', {position: [ 4  , -22  , 0]}),
      fM('Fortress_Wall'           , {position: [ 5.5, -22  , 0]}),
      fM('Fortress_Wall_Battlement', {position: [ 7  , -22  , 0]}),
      fM('Fortress_Wall'           , {position: [ 8.5, -22  , 0]}),
      fM('Fortress_Wall_Battlement', {position: [10  , -22  , 0]}),
      
      fM('Fortress_Corner', {position: [11, -22, 0], euler: [0, 0, 0.5*Math.PI]}),
      
      fM('Fortress_Wall'           , {position: [11, -19.5, 0], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [11, -18  , 0], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Wall'           , {position: [11, -16.5, 0], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [11, -15  , 0], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Wall'           , {position: [11, -13.5, 0], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [11, -12  , 0], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Wall'           , {position: [11, -10.5, 0], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [11, - 9  , 0], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Wall'           , {position: [11, - 7.5, 0], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [11, - 6  , 0], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Wall'           , {position: [11, - 4.5, 0], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [11, - 3  , 0], euler: [0, 0, 0.5*Math.PI]}),
      
      fM('Harbor_Bridge'           , {position: [11, 0, 0], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [11, 0, 0], euler: [0, 0, 0.5*Math.PI]}),
      
      fM('Fortress_Wall_Battlement', {position: [11, 3  , 0], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Wall'           , {position: [11, 4.5, 0], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [11, 6  , 0], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Wall'           , {position: [11, 7.5, 0], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [11, 9  , 0], euler: [0, 0, 0.5*Math.PI]}),
      
      fM('Fortress_Corner', {position: [11, 10, 0], euler: [0, 0, Math.PI]}),
      
      fM('Fortress_Wall_Battlement', {position: [ 10  , 10, 0], euler: [0, 0, Math.PI]}),
      fM('Fortress_Wall'           , {position: [  8.5, 10, 0], euler: [0, 0, Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [  7  , 10, 0], euler: [0, 0, Math.PI]}),
      fM('Fortress_Wall'           , {position: [  5.5, 10, 0], euler: [0, 0, Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [  4  , 10, 0], euler: [0, 0, Math.PI]}),
      fM('Fortress_Wall'           , {position: [  2.5, 10, 0], euler: [0, 0, Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [  1  , 10, 0], euler: [0, 0, Math.PI]}),
      fM('Fortress_Wall'           , {position: [- 0.5, 10, 0], euler: [0, 0, Math.PI]}),
      
      fM('Fortress_Inner_Corner', {position: [-3, 10, 0]}),
      
      fM('Fortress_Wall'           , {position: [-3, 12  , 0], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [-3, 13.5, 0], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Wall'           , {position: [-3, 15  , 0], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [-3, 16.5, 0], euler: [0, 0, 0.5*Math.PI]}),
      
      fM('Fortress_Gate_3'           , {position: [-4   , 20.5, 0  ], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Gate_3_Wall'      , {position: [ 2.5 , 20.5, 0  ], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Gate_1_Banner'    , {position: [ 3.25, 18  , 7.8], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Gate_1_Banner'    , {position: [ 3.25, 23  , 7.8], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Gate_3_Drawbridge', {position: [ 3   , 20.5, 3.8]}),
      fM('Fortress_Dock'             , {position: [ 8.5 , 20.5, 0  ]}),
      
      fM('Fortress_Wall_Battlement', {position: [-3, 24.5, 0], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Wall'           , {position: [-3, 26  , 0], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [-3, 27.5, 0], euler: [0, 0, 0.5*Math.PI]}),
      fM('Fortress_Wall'           , {position: [-3, 29  , 0], euler: [0, 0, 0.5*Math.PI]}),
      
      fM('Fortress_Corner', {position: [-3, 31.5, 0], euler: [0, 0, Math.PI]}),
      
      fM('Fortress_Wall_Battlement', {position: [- 4  , 31.5, 0], euler: [0, 0, Math.PI]}),
      fM('Fortress_Wall'           , {position: [- 5.5, 31.5, 0], euler: [0, 0, Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [- 7  , 31.5, 0], euler: [0, 0, Math.PI]}),
      fM('Fortress_Wall'           , {position: [- 8.5, 31.5, 0], euler: [0, 0, Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [-10  , 31.5, 0], euler: [0, 0, Math.PI]}),
      
      fM('Fortress_Corner', {position: [-11, 31.5, 0], euler: [0, 0, 1.5*Math.PI]}),
      
      fM('Fortress_Wall'           , {position: [-11, 29, 0], euler: [0, 0, 1.5*Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [-11, 27.5, 0], euler: [0, 0, 1.5*Math.PI]}),
      fM('Fortress_Wall'           , {position: [-11, 26, 0], euler: [0, 0, 1.5*Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [-11, 24.5, 0], euler: [0, 0, 1.5*Math.PI]}),
      
      f3D(fortressGate2, {position: [-10, 20.5, 0], euler: [0, 0, 1.5*Math.PI]}),
      
      fM('Fortress_Wall_Battlement', {position: [-11,  16.5 , 0], euler: [0, 0, 1.5*Math.PI]}),
      fM('Fortress_Wall'           , {position: [-11,  15   , 0], euler: [0, 0, 1.5*Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [-11,  13.5 , 0], euler: [0, 0, 1.5*Math.PI]}),
      fM('Fortress_Wall'           , {position: [-11,  12   , 0], euler: [0, 0, 1.5*Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [-11,  10.75, 0], euler: [0, 0, 1.5*Math.PI]}),
      fM('Fortress_Wall'           , {position: [-11,   9.5 , 0], euler: [0, 0, 1.5*Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [-11,   8   , 0], euler: [0, 0, 1.5*Math.PI]}),
      fM('Fortress_Wall'           , {position: [-11,   6.5 , 0], euler: [0, 0, 1.5*Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [-11,   5   , 0], euler: [0, 0, 1.5*Math.PI]}),
      fM('Fortress_Wall'           , {position: [-11,   3.5 , 0], euler: [0, 0, 1.5*Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [-11,   2   , 0], euler: [0, 0, 1.5*Math.PI]}),
      fM('Fortress_Wall'           , {position: [-11,   0.5 , 0], euler: [0, 0, 1.5*Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [-11, - 1   , 0], euler: [0, 0, 1.5*Math.PI]}),
      fM('Fortress_Wall'           , {position: [-11, - 2.5 , 0], euler: [0, 0, 1.5*Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [-11, - 4   , 0], euler: [0, 0, 1.5*Math.PI]}),
      
      f3D(fortressGate2, {position: [-10, -8, 0], euler: [0, 0, 1.5*Math.PI]}),
      
      fM('Fortress_Wall_Battlement', {position: [-11, -12  , 0], euler: [0, 0, 1.5*Math.PI]}),
      fM('Fortress_Wall'           , {position: [-11, -13.5, 0], euler: [0, 0, 1.5*Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [-11, -15  , 0], euler: [0, 0, 1.5*Math.PI]}),
      fM('Fortress_Wall'           , {position: [-11, -16.5, 0], euler: [0, 0, 1.5*Math.PI]}),
      fM('Fortress_Wall_Battlement', {position: [-11, -18  , 0], euler: [0, 0, 1.5*Math.PI]}),
      fM('Fortress_Wall'           , {position: [-11, -19.5, 0], euler: [0, 0, 1.5*Math.PI]}),
      
      fM('Fortress_Corner'         , {position: [-11, -22, 0]}),
      
      fM('Fortress_Wall_Battlement', {position: [-10  , -22, 0]}),
      fM('Fortress_Wall'           , {position: [- 8.5, -22, 0]}),
      fM('Fortress_Wall_Battlement', {position: [- 7  , -22, 0]}),
      fM('Fortress_Wall'           , {position: [- 5.5, -22, 0]}),
      fM('Fortress_Wall_Battlement', {position: [- 4  , -22, 0]}),
      
      fM('Citadel_Door_Side', {}),
      fM('Citadel_Door'     , {position: [-1.275, -2.85, 5.1]}),
      fM('Citadel_Side'     , {euler: [0, 0, 0.5*Math.PI]}),
      fM('Citadel_Side'     , {euler: [0, 0,     Math.PI]}),
      fM('Citadel_Side'     , {euler: [0, 0, 1.5*Math.PI]}),
      fM('Citadel_Mezzanine', {}),
      fM('Citadel_Mezzanine', {euler: [0, 0, 0.5*Math.PI]}),
      fM('Citadel_Mezzanine', {euler: [0, 0,     Math.PI]}),
      fM('Citadel_Mezzanine', {euler: [0, 0, 1.5*Math.PI]}),
      
      fM('Fortress_Causeway_Drop'      , {position: [ 0    , -8, 0   ]}),
      fM('Fortress_Causeway'           , {position: [-6.5  , -8, 0   ]}),
      fM('Fortress_Causeway_Drawbridge', {position: [-7.275, -8, 3.55]}),
      fM('Fortress_Causeway'           , {position: [ 6.5  , -8, 0   ], euler: [0, 0, Math.PI]}),
      fM('Fortress_Causeway_Drawbridge', {position: [ 7.275, -8, 3.55], euler: [0, 0, Math.PI]}),
      
      f3D(fortressTower2, {position: [-6.5, -19, 0]}),
      f3D(fortressTower1, {position: [ 6.5, -19, 0]}),
      f3D(fortressTower2, {position: [ 7  ,   7, 0], euler: [0, 0, Math.PI]}),
      
      f3D(keep, {position: [-21.5, -23, 0]}),
      fM('Fortress_Bridge'       , {position: [-14.75, -21, 4.2]}),
      fM('Fortress_Bridge_Wall_2', {position: [-14.75, -21, 0  ]}),
      fM('Keep_Wall_Battlement'  , {position: [-23.5 , -26, 0  ]}),
      fM('Keep_Wall_Battlement'  , {position: [-18.5 , -25, 0  ], euler: [0, 0, 0.5*Math.PI]}),
      
      fM('Annex_Wall_S_End'    , {position: [-23.5, -18   , 0]}),
      fM('Annex_Wall_2'        , {position: [-23.5, -14   , 0]}),
      f3D(annexGate            , {position: [-23.5, - 8   , 0]}),
      fM('Annex_Wall_2'        , {position: [-23.5, - 2   , 0]}),
      fM('Annex_Wall_1'        , {position: [-23.5,   2   , 0]}),
      fM('Annex_Wall_Stretched', {position: [-23.5,   6.25, 0]}),
      fM('Annex_Wall_1'        , {position: [-23.5,  10.5 , 0]}),
      fM('Annex_Wall_2'        , {position: [-23.5,  14.5 , 0]}),
      f3D(annexGate            , {position: [-23.5,  20.5 , 0]}),
      fM('Annex_Wall_2'        , {position: [-23.5,  26.5 , 0]}),
      
      f3D(keep, {position: [-21.5, 32.5, 0]}),
      fM('Fortress_Bridge'                , {position: [-14.75, 30.5, 4.2]}),
      fM('Fortress_Bridge_Wall_Mirrored_2', {position: [-14.75, 30.5, 0  ]}),
      fM('Keep_Wall_Battlement'           , {position: [-23.5 , 35.5, 0  ], euler: [0, 0, Math.PI]}),
      fM('Keep_Wall_Battlement'           , {position: [-18.5 , 34.5, 0  ], euler: [0, 0, 0.5*Math.PI]}),
      
      f3D(gildedKeep, {position: [20.5, -23, 0]}),
      fM('Gilded_Fortress_Bridge', {position: [14.5, -21, 4.2]}),
      fM('Gilded_Bridge_Wall'    , {position: [14.5, -21, 0  ]}),
      
      fM('Harbor_Tower_S'      , {position: [22.5, -15  , 0  ]}),
      fM('Keep_Dock_Bridge'    , {position: [21  , -17  , 4.4]}),
      fM('Keep_Dock'           , {position: [18.5, -17  , 0  ]}),
      fM('Harbor_Gate'         , {position: [22.5, - 3.5, 0  ]}),
      fM('Harbor_Island_Door'  , {position: [23.5, - 4.5, 3.8]}),
      fM('Harbor_Island'       , {position: [22.5,   1.5, 0  ]}),
      fM('Harbor_Island_Door'  , {position: [21.5,   7.5, 3.8], euler: [0, 0, Math.PI]}),
      fM('Harbor_Gate_Mirrored', {position: [22.5,   6.5, 0  ]}),
      fM('Harbor_Gate'         , {position: [22.5,  21.5, 0  ]}),
      fM('Harbor_Tower_N'      , {position: [22.5,  24.5, 0  ]}),
      
      f3D(harborKeep, {position: [24.5, 32.5, 0]}),
      fM('Fortress_Bridge'                 , {position: [ 0.75, 30.5, 4.2], euler: [0, 0, Math.PI]}),
      fM('Fortress_Bridge_Extension'       , {position: [ 5.75, 30.5, 4.2], euler: [0, 0, Math.PI]}),
      fM('Fortress_Bridge_Extension'       , {position: [10.25, 30.5, 4.2], euler: [0, 0, Math.PI]}),
      fM('Fortress_Bridge_Wall_1'          , {position: [ 0.75, 30.5, 0  ], euler: [0, 0, Math.PI]}),
      fM('Fortress_Bridge_Wall_1_Extension', {position: [ 5.75, 30.5, 0  ], euler: [0, 0, Math.PI]}),
      fM('Fortress_Bridge_Wall_1_Extension', {position: [10.25, 30.5, 0  ], euler: [0, 0, Math.PI]}),
    ])
  );
});







/////////////////////////
// Tick initialization //
/////////////////////////

var timePrevious = Date.now(), timeDelta = 0;

function tick() {
  timeDelta = -timePrevious + (timePrevious = Date.now());
  
  // Also updates scene-wide shader materials, because they are applied to the water mesh too
  if(water.material.tick) water.material.tick(timeDelta/1000);
  
  renderer.render(scene, camera);
  
  requestAnimationFrame(tick);
}

tick();

// Startup scripts //

eval(localStorage.onstart);

</script>
</html>
