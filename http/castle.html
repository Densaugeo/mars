<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">

<title>A Castle in the Cloud</title>

<script type="text/javascript">
// Frame buster
if(top !== self) {
  top.location.replace(self.location.href);
}
</script>

<script type="text/javascript" src="draggabilly.pkgd.min.js"></script>
<script type="text/javascript" src="EventEmitter.min.js"></script>
<script type="text/javascript" src="panelui.js"></script>
<script type="text/javascript" src="three.min.js"></script>
<script type="text/javascript" src="three.Densaugeo.js"></script>
<script type="text/javascript" src="castleMap.js"></script>

<!-- js-objectdetect vision testing -->
<script src="objectdetect/compatibility.js"></script>
<script src="objectdetect/smoother.js"></script>
<script src="objectdetect/objectdetect.js"></script>
<script src="objectdetect/objectdetect.frontalface.js"></script>

<link rel="stylesheet" href="font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="panelui_light.css" id="light_colors">
<link rel="stylesheet" href="panelui_dark.css" id="dark_colors">
<link rel="stylesheet" href="panelui.css">

<style type="text/css">
body {
  z-index: -2;
  height: 0;
}

canvas {
  position: absolute;
  top:      0;
  bottom:   0;
  left:     48px;
  right:    0;
  z-index: -1;
  padding:  0;
  border:   none;
  margin:   0;
}

#help,
#shader,
#eye {
  top: 12px;
  left: 60px;
}

#eye {
  min-width: 200px;
}

.button.active_shader {
  color: #00F;
}

</style>
</head>

<body>

<video id="video" style="visibility: hidden; z-index: -10"></video>

<div id="test_output"></div>

<a title="Real Time Web Analytics" style="visibility:hidden" href="http://clicky.com/100755588"><img alt="Real Time Web Analytics" src="//static.getclicky.com/media/links/badge.gif" border="0" /></a>
<script type="text/javascript">
var clicky_site_ids = clicky_site_ids || [];
clicky_site_ids.push(100755588);
(function() {
  var s = document.createElement('script');
  s.type = 'text/javascript';
  s.async = true;
  s.src = '//static.getclicky.com/js';
  ( document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0] ).appendChild( s );
})();
</script>
<noscript><p><img alt="Clicky" width="1" height="1" src="//in.getclicky.com/100755588ns.gif" /></p></noscript>

</body>

<script type="text/javascript">

////////
// UI //
////////

var sidebar = new PanelUI.Sidebar();

sidebar.addButton({buttonName: 'land', faClass: 'fa-university', title: 'Landing page'});
sidebar.on('land', function(e) {
  document.location.href = document.location.origin + '/index.html';
});

var helpPanel = new PanelUI.Panel({id: 'help', heading: 'Controls', startOpen: false, accessKey: 'c'});
helpPanel.domElement.appendChild(fE('div', {}, [
  fE('text', {textContent: 'Touchscreen:'}),
  fE('br'),
  fE('text', {textContent: 'First finger drag - Pan'}),
  fE('br'),
  fE('text', {textContent: 'Second finger drag - Rotate'}),
  fE('br'),
  fE('text', {textContent: 'Slide along right edge - Throttle'}),
  fE('br'),
  fE('br'),
  fE('text', {textContent: 'Mouse:'}),
  fE('br'),
  fE('text', {textContent: 'Left click and drag - Pan'}),
  fE('br'),
  fE('text', {textContent: 'Right click and drag - Rotate'}),
  fE('br'),
  fE('text', {textContent: 'Scroll wheel - Dolly'}),
  fE('br'),
  fE('text', {textContent: 'Shift click - Activate mouse look'}),
  fE('br'),
  fE('text', {textContent: 'Esc - Exit mouse look'}),
  fE('br'),
  fE('br'),
  fE('text', {textContent: 'Keyboard:'}),
  fE('br'),
  fE('text', {textContent: 'W/S - Fly forward/backward'}),
  fE('br'),
  fE('text', {textContent: 'A/D - Strafe left/right'}),
  fE('br'),
  fE('text', {textContent: 'E/C - Ascend/Descend'}),
  fE('br'),
  fE('text', {textContent: 'Arrows - Turn'}),
  fE('br'),
  fE('br'),
  fE('text', {textContent: 'Gamepad (press any face button to activate):'}),
  fE('br'),
  fE('text', {textContent: 'Left stick - Pan'}),
  fE('br'),
  fE('text', {textContent: 'Right stick - Turn'}),
  fE('br'),
  fE('text', {textContent: 'Left/right trigger - Throttle back/forward'}),
]));

sidebar.addButton({buttonName: 'help', faClass: 'fa-question', title: 'Help'});
sidebar.on('help', function(e) {
  helpPanel.isOpen() ? helpPanel.close() : helpPanel.open();
});

var shaderChanger = new function() {
  EventEmitter.call(this);
  
  this.shaders = {
    original: 'original',
    global: new THREE.Densaugeo.CoordinateMaterial({transparent: true}),
    local: new THREE.Densaugeo.CoordinateMaterial({transparent: true, side: THREE.DoubleSide, local: true, showAxes: new THREE.Vector3(0, 0, 0)}),
    ghost: new THREE.Densaugeo.PositionMaterial({transparent: true, alpha: 0.8}),
    normals: new THREE.Densaugeo.NormalMaterial({transparent: true}),
    psychedelic: new THREE.Densaugeo.PsychMaterial({transparent: true}),
  }
  
  this.shaderSequence = ['original', 'global', 'local', 'ghost', 'normals', 'psychedelic'];
  this.currentShader = 'original';
  
  var changeMaterial = function(object, material) {
    if(object instanceof THREE.Mesh) {
      if(object.originalMaterial == null) {
        object.originalMaterial = object.material;
      }
      
      object.material = material === 'original' ? object.originalMaterial : material;
    }
    
    if(object instanceof THREE.Object3D) {
      for(var i = 0, endi = object.children.length; i < endi; ++i) {
        changeMaterial(object.children[i], material);
      }
    }
  }
  
  with(this) this.nextMaterial = function(object) {
    var previousShader = currentShader;
    
    currentShader = shaderSequence[(shaderSequence.indexOf(currentShader) + 1) % shaderSequence.length];
    
    changeMaterial(object, shaders[currentShader]);
    
    emit('change', {currentShader: currentShader, previousShader: previousShader});
  }
  
  with(this) this.setMaterial = function(object, /*string*/ shaderName) {
    var previousShader = currentShader;
    
    currentShader = shaderName;
    
    changeMaterial(object, shaders[currentShader]);
    
    emit('change', {currentShader: currentShader, previousShader: previousShader});
  }
}
shaderChanger.__proto__ = Object.create(EventEmitter.prototype);

sidebar.addButton({buttonName: 'shader', faClass: 'fa-step-forward', title: 'Change shader'});
sidebar.on('shader', function(e) {
  //changeMaterials(scene);
  shaderChanger.nextMaterial(scene);
});

if(HTMLElement.prototype.requestFullscreen == null) {
  HTMLElement.prototype.requestFullscreen = HTMLElement.prototype.msRequestFullscreen || HTMLElement.prototype.mozRequestFullScreen || HTMLElement.prototype.webkitRequestFullscreen;
}
if(document.exitFullscreen == null) {
  document.exitFullscreen = document.msExitFullscreen || document.mozCancelFullScreen || document.webkitExitFullscreen;
}
var getFullscreenElement = function() {
  return document.fullscreenElement || document.msFullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;
}

sidebar.addButton({buttonName: 'fs', faClass: 'fa-arrows-alt', title: 'Fullscreen'});
sidebar.on('fs', function(e) {
  if(getFullscreenElement() == null) {
    document.body.requestFullscreen();
  } else {
    document.exitFullscreen();
  }
});

var darkColors = document.getElementById('dark_colors');
var head = darkColors.parentNode;
var contrastFlipped = false;

if(localStorage.contrast === 'light') {
  head.removeChild(darkColors);
}

sidebar.addButton({buttonName: 'contrast', faClass: 'fa-adjust', title: 'Flip Contrast'});
sidebar.on('contrast', function(e) {
  if(contrastFlipped = !contrastFlipped) {
    head.removeChild(darkColors);
    localStorage.contrast = 'light';
  } else {
    head.appendChild(darkColors);
    localStorage.contrast = 'dark';
  }
});

sidebar.addButton({buttonName: 'clear', faClass: 'fa-recycle', title: 'Clear local storage'});
sidebar.on('clear', function(e) {
  localStorage.clear();
});

var shaderPanel = new PanelUI.Panel({id: 'shader', heading: 'Shader Settings', accessKey: 's'});

shaderPanel.shaderButtons = {};
shaderPanel.controls = {};

shaderPanel.content = fE('div', {}, [
  fE('br'),
  fE('text', {textContent: 'Current shader:'}),
  fE('br'),
  shaderPanel.shaderButtons.original    = fE('b', {className: 'button active_shader', title: 'Phong', textContent: 'P', tabIndex: 0}),
  shaderPanel.shaderButtons.global      = fE('b', {className: 'button', title: 'Global coordinate grid', textContent: 'G', tabIndex: 0}),
  shaderPanel.shaderButtons.local       = fE('b', {className: 'button', title: 'Local coordinate grid', textContent: 'L', tabIndex: 0}),
  shaderPanel.shaderButtons.ghost       = fE('b', {className: 'button', title: 'Ghostly', textContent: 'H', tabIndex: 0}),
  shaderPanel.shaderButtons.normals     = fE('b', {className: 'button', title: 'RGB-encoded normals', textContent: 'N', tabIndex: 0}),
  shaderPanel.shaderButtons.psychedelic = fE('b', {className: 'button', title: 'Psychedelic', textContent: 'S', tabIndex: 0}),
  fE('div', {}, [
    fE('text', {textContent: 'Alpha:'}),
    shaderPanel.controls.alpha = fE('input', {type: 'range', min: 0, max: 1, step: 0.01}),
  ]),
  fE('div', {}, [
    fE('text', {textContent: 'Local:'}),
    shaderPanel.controls.local = fE('input', {type: 'range', min: 0, max: 1, step: 1}),
  ]),
  fE('div', {}, [
    fE('text', {textContent: 'Sun direction:'}),
    shaderPanel.controls.sunDirection = fE('input', {type: 'text'}),
  ]),
  fE('div', {}, [
    fE('text', {textContent: 'Ambient color:'}),
    shaderPanel.controls.ambient = fE('input', {type: 'text'}),
  ]),
  fE('div', {}, [
    fE('text', {textContent: 'Diffuse color:'}),
    shaderPanel.controls.diffuse = fE('input', {type: 'text'}),
  ]),
  fE('div', {}, [
    fE('text', {textContent: 'Specular color:'}),
    shaderPanel.controls.specular = fE('input', {type: 'text'}),
  ]),
  fE('div', {}, [
    fE('text', {textContent: 'Show axes:'}),
    shaderPanel.controls.showAxes = fE('input', {type: 'text'}),
  ]),
  fE('div', {}, [
    fE('text', {textContent: 'Axis weight:'}),
    shaderPanel.controls.axisWeight = fE('input', {type: 'text'}),
  ]),
  fE('div', {}, [
    fE('text', {textContent: 'Show grid:'}),
    shaderPanel.controls.showGrid = fE('input', {type: 'text'}),
  ]),
  fE('div', {}, [
    fE('text', {textContent: 'Grid weight:'}),
    shaderPanel.controls.gridWeight = fE('input', {type: 'text'}),
  ]),
  fE('div', {}, [
    fE('text', {textContent: 'Grid spacing:'}),
    shaderPanel.controls.gridSpacing = fE('input', {type: 'text'}),
  ]),
  fE('div', {}, [
    fE('text', {textContent: 'Fade distance:'}),
    shaderPanel.controls.fadeDistance = fE('input', {type: 'text'}),
  ]),
  fE('div', {}, [
    fE('text', {textContent: 'Mode:'}),
    shaderPanel.controls.mode = fE('input', {type: 'range', min: 0, max: 1, step: 1}),
  ]),
  fE('div', {}, [
    fE('text', {textContent: 'Wavelength:'}),
    shaderPanel.controls.wavelength = fE('input', {type: 'text'}),
  ]),
  fE('div', {}, [
    fE('text', {textContent: 'Frequency:'}),
    shaderPanel.controls.frequency = fE('input', {type: 'text'}),
  ]),
]);
shaderPanel.domElement.appendChild(shaderPanel.content);

shaderPanel.keyCuts[80] = shaderPanel.shaderButtons.original;
shaderPanel.keyCuts[71] = shaderPanel.shaderButtons.global;
shaderPanel.keyCuts[76] = shaderPanel.shaderButtons.local;
shaderPanel.keyCuts[72] = shaderPanel.shaderButtons.ghost;
shaderPanel.keyCuts[78] = shaderPanel.shaderButtons.normals;
shaderPanel.keyCuts[83] = shaderPanel.shaderButtons.psychedelic;

for(var i in shaderPanel.shaderButtons) {
  with({i: i}) shaderPanel.shaderButtons[i].addEventListener('click', function(e) {
    shaderChanger.setMaterial(scene, i);
  });
}

for(var i in shaderPanel.controls) {
  switch(shaderPanel.controls[i].type) {
    case 'range':
      with({i: i}) shaderPanel.controls[i].addEventListener('input', function(e) {
        water.material[i] = shaderPanel.controls[i].value;
        water.material.updateUniforms();
      });
      break;
    case 'text':
      with({i: i}) shaderPanel.controls[i].addEventListener('change', function(e) {
        water.material[i].fromString(shaderPanel.controls[i].value);
        water.material.updateUniforms();
      });
      
      shaderPanel.controls[i].addEventListener('keydown', function(e) {
        e.stopPropagation();
      });
      break;
  }
}

shaderPanel.update = function(e) {
  if(e && shaderPanel.shaderButtons[e.previousShader]) {
    shaderPanel.shaderButtons[e.previousShader].classList.remove('active_shader');
  }
  
  if(e && shaderPanel.shaderButtons[e.currentShader]) {
    shaderPanel.shaderButtons[e.currentShader].classList.add('active_shader');
  }
  
  for(var i in shaderPanel.controls) {
    if(water.material[i] != null) {
      shaderPanel.controls[i].parentElement.style.display = '';
      shaderPanel.controls[i].value = water.material[i].toString();
    } else {
      shaderPanel.controls[i].parentElement.style.display = 'none';
    }
  }
}

shaderChanger.on('change', shaderPanel.update);

castleMap.on('loaded', shaderPanel.update);

sidebar.addButton({buttonName: 'shader_settings', faClass: 'fa-cog', title: 'Adjust shader settings'});
sidebar.on('shader_settings', function(e) {
  shaderPanel.isOpen() ? shaderPanel.close() : shaderPanel.open();
  shaderPanel.domElement.focus();
});

var eyePanel = new PanelUI.Panel({id: 'eye', heading: 'Eye Tracking', startOpen: false, accessKey: 'e'});

eyePanel.videoElement = document.getElementById('video');
//eyePanel.detector = {};
eyePanel.estimate = {x: 0, y: 0};
eyePanel.tracking = false;
eyePanel.faceWidthAtHalfMeter = 25;
eyePanel.camWidth = 60;
eyePanel.camHeight = 60;
eyePanel.horizontalAngle = 70/180*Math.PI;
eyePanel.verticalAngle = 43/180*Math.PI;
eyePanel.cameraPosition = new THREE.Vector3(0, 0.175, -0.5);
eyePanel.cameraRotation = new THREE.Euler(1/8*Math.PI, 0, 0);
eyePanel.cameraMatrix = new THREE.Matrix4().compose(eyePanel.cameraPosition, new THREE.Quaternion().setFromEuler(eyePanel.cameraRotation), new THREE.Vector3(1, 1, 1));

eyePanel.updateEstimate = function(data) {
  var delta = {}, alpha = {};
  
  delta.x = Math.abs(data.x - this.estimate.x);
  delta.y = Math.abs(data.y - this.estimate.y);
  
  alpha.x = 0.1 + 0.8*Math.min(Math.max((delta.x/10), 0), 1);
  alpha.y = 0.1 + 0.8*Math.min(Math.max((delta.y/10), 0), 1);
  
  this.estimate.x += alpha.x*(data.x - this.estimate.x);
  this.estimate.y += alpha.y*(data.y - this.estimate.y);
}

// Converts camera coordinates into 3D position relative to camera
eyePanel.positionFromCoords = function(xAngle, yAngle, width) {
  var result = new THREE.Vector3();
  var distance = eyePanel.faceWidthAtHalfMeter/width*0.5;
  
  with(Math) {
    result.z = distance/sqrt(pow(tan(xAngle), 2) + pow(tan(yAngle), 2) + 1);
    result.x = -result.z*tan(xAngle);
    result.y = -result.z*tan(yAngle);
  }
  
  return result;
}

eyePanel.play = function() {
  if(!eyePanel.tracking) {
    return;
  }
  
  if (eyePanel.videoElement.readyState === eyePanel.videoElement.HAVE_ENOUGH_DATA && eyePanel.videoElement.videoWidth > 0) {
    // Prepare the detector once the video dimensions are known:
    if (!eyePanel.detector) {
      eyePanel.camWidth = ~~(60 * eyePanel.videoElement.videoWidth / eyePanel.videoElement.videoHeight);
      eyePanel.detector = new objectdetect.detector(eyePanel.camWidth, eyePanel.camHeight, 1.1, objectdetect.frontalface);
    }
    
    // Perform the actual detection:
    var coords = eyePanel.detector.detect(video, 1);
    if (coords[0]) {
      var coord = coords[0];
      
      // Coord appears to have the form [left, top, width, height, some integer]
      eyePanel.updateEstimate({x: coord[0] + coord[2]/2, y: coord[1] + coord[3]/2});
      
      var xAngle = (eyePanel.estimate.x - eyePanel.camWidth/2)/eyePanel.camWidth*eyePanel.horizontalAngle;
      var yAngle = (eyePanel.estimate.y - eyePanel.camHeight/2)/eyePanel.camHeight*eyePanel.verticalAngle;
      
      var eyePosition = eyePanel.positionFromCoords(xAngle, yAngle, coord[2]);
      eyePosition.add(eyePanel.cameraPosition).multiplyScalar(10);
      
      camera.matrix.makeRotationFromEuler(new THREE.Euler(0.2*yAngle, -0.2*xAngle, 0, 'XYZ'));
      camera.matrix.setPosition(eyePosition);
    }
  }
  
  requestAnimationFrame(eyePanel.play);
}

eyePanel.domElement.appendChild(fE('div', {}, [
  eyePanel.powerButton     = fE('i', {className: 'fa fa-power-off button', title: 'O - Turn eye tracking on/off', tabIndex: 0}),
  eyePanel.calibrateButton = fE('i', {className: 'fa fa-circle-thin button', title: 'C - Set eye base point', tabIndex: 0}),
  fE('div', {}, [
    fE('text', {textContent: 'Camera positition (cm):'}),
    eyePanel.camPosition = fE('input', {type: 'text'}),
  ]),
  fE('div', {}, [
    fE('text', {textContent: 'Camera rotation (rad, Euler XYZ):'}),
    eyePanel.camRotation = fE('input', {type: 'text'}),
  ]),
  fE('div', {}, [
    fE('text', {textContent: 'Test data:'}),
    eyePanel.testData = fE('text'),
  ]),
]));

eyePanel.keyCuts[67] = eyePanel.calibrateButton; // C
eyePanel.keyCuts[79] = eyePanel.powerButton; // O

eyePanel.powerButton.addEventListener('click', function(e) {
  eyePanel.tracking = !eyePanel.tracking;
  
  if(eyePanel.videoElement.src === "") {
    compatibility.getUserMedia({video: true}, function(stream) {
      try {
        eyePanel.videoElement.src = compatibility.URL.createObjectURL(stream);
      }
      catch(error) {
        eyePanel.videoElement.src = stream;
      }
    }, function(error) {
      alert('WebRTC not available');
    });
  }
  
  if(eyePanel.tracking) {
    eyePanel.videoElement.play();
    requestAnimationFrame(eyePanel.play);
  }
  else {
    eyePanel.videoElement.pause();
  }
});

eyePanel.calibrateButton.addEventListener('click', function(e) {
  eyePanel.needsCalibration = true;
});

sidebar.addButton({buttonName: 'eye', faClass: 'fa-eye', title: 'Eye tracking'});
sidebar.on('eye', function(e) {
  eyePanel.isOpen() ? eyePanel.close() : eyePanel.open();
  eyePanel.domElement.focus();
});

/////////////////
// THREE setup //
/////////////////

var scene = new THREE.Scene();

var camera = new THREE.PerspectiveCamera(45, (window.innerWidth - 48)/window.innerHeight, 1, 1000);
camera.matrixAutoUpdate = false;

var cameraHolder = new THREE.Object3D();
cameraHolder.matrix.set(
  0.8583453893661499, -0.2562495470046997, 0.4444985091686249, 28.422760009765625,
  0.5130719542503357, 0.4286935329437256, -0.7436251044273376, -49.2386474609375,
  0, 0.8663473129272461, 0.49944186210632324, 27.35080909729004,
  0, 0, 0, 1
);

cameraHolder.add(camera);
scene.add(cameraHolder);

var ambientLight = new THREE.AmbientLight(0x7F7F7F);
scene.add(ambientLight);

var directionalLight = new THREE.DirectionalLight(0x808080);
directionalLight.position.set(-7.1, 2.75, 10);
scene.add(directionalLight);

var loader = new THREE.Densaugeo.JSONMultiLoader();

var renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth - 48, window.innerHeight);
renderer.setClearColor(0xC0C0C0, 1);

document.body.appendChild(renderer.domElement);

var controls = new THREE.Densaugeo.FreeControls(cameraHolder, renderer.domElement, {panMouseSpeed: 0.05, dollySpeed: 5});

// WebGL occupies entire browser window
window.addEventListener("resize", function() {
  camera.aspect = (window.innerWidth - 48)/window.innerHeight;
  camera.updateProjectionMatrix();
  
  renderer.setSize(window.innerWidth - 48, window.innerHeight);
});

// Put stuff in scene
scene.add(castleMap.castle);

castleMap.load();

//scene.add(f3D(THREE.Mesh, {geometry: new THREE.PlaneGeometry(128, 128, 1, 1), material: waterShader, position: [0, 0, -0.5]}));
scene.add(water = f3D(THREE.Mesh, {geometry: new THREE.PlaneGeometry(128, 128, 1, 1), material: new THREE.Densaugeo.WaterMaterial({side: THREE.DoubleSide}), position: [0, 0, -0.5]}));

/////////////////////////
// Tick initialization //
/////////////////////////

var timePrevious = Date.now(), timeDelta = 0;

function tick() {
  timeDelta = -timePrevious + (timePrevious = Date.now());
  
  // Also updates scene-wide shader materials, because they are applied to the water mesh too
  if(water.material.tick) water.material.tick(timeDelta/1000);
  
  renderer.render(scene, camera);
  
  requestAnimationFrame(tick);
}

tick();

// Startup scripts //

eval(localStorage.onstart);

</script>
</html>
